\section{Union Find Disjoint Sets}

The Union Find Disjoint Sets data structure is used to keep track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. It supports two operations:

\begin{itemize}
\item \textbf{Find}: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.
\item \textbf{Union}: Join two subsets into a single subset.
\end{itemize}

The implementation is as follows:

\lstinputlisting{../Data Structures/UnionFind.cpp}

\section{Binary Indexed (Fenwick) Tree}

The Binary Indexed Tree (BIT) is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. It is also called a Fenwick Tree, as it was first described by Peter Fenwick. The implementation is as follows:

\lstinputlisting{../Data Structures/FenwickTree.cpp}

This Data Structure can also be used to find the maximum value in a range of values in an array.

It can also be extended to 2D, 3D, etc. The implementation is as follows:

\lstinputlisting{../Data Structures/FenwickTree2D.cpp}

\section{Segment Tree}

The Segment Tree is a data structure that allows answering range queries over an array effectively, while still being flexible enough to allow modifying the array. It is, in principle, a static structure. It can answer most queries in O($\log$ n), but its true power is answering range updates. For that, it takes O($\log$ n) time per update.

The implementation is as follows:

\lstinputlisting{../Data Structures/SegmentTree.cpp}

An iterative implementation is also possible:

\lstinputlisting{../Data Structures/SegmentTreeIterative.cpp}