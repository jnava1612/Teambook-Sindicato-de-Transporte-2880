\section{Union Find Disjoint Sets}

The Union Find Disjoint Sets data structure is used to keep track of a set of elements partitioned into a number of disjoint (non-overlapping) subsets. It supports two operations:

\begin{itemize}
\item \textbf{Find}: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.
\item \textbf{Union}: Join two subsets into a single subset.
\end{itemize}

The implementation is as follows:

\lstinputlisting{../Data Structures/UnionFind.cpp}

\section{Binary Indexed (Fenwick) Tree}

The Binary Indexed Tree (BIT) is a data structure that can efficiently update elements and calculate prefix sums in a table of numbers. It is also called a Fenwick Tree, as it was first described by Peter Fenwick. The implementation is as follows:

\lstinputlisting{../Data Structures/FenwickTree.cpp}

This Data Structure can also be used to find the maximum value in a range of values in an array.

It can also be extended to 2D, 3D, etc. The implementation is as follows:

\lstinputlisting{../Data Structures/FenwickTree2D.cpp}

\section{Segment Tree}

The Segment Tree is a data structure that allows answering range queries over an array effectively, while still being flexible enough to allow modifying the array. It is, in principle, a static structure. It can answer most queries in O($\log$ n), but its true power is answering range updates. For that, it takes O($\log$ n) time per update.

The implementation is as follows:

\lstinputlisting{../Data Structures/SegmentTree.cpp}

An iterative implementation is also possible:

\lstinputlisting{../Data Structures/SegmentTreeIterative.cpp}


Another useful tool while using the Segment Tree is the Lazy Propagation technique. This technique allows us to perform range updates in O($\log$ n) time. The implementation is as follows:

\lstinputlisting{../Data Structures/LazyPropagation.cpp}

\lstinputlisting{../Data Structures/LazyPropagation2.cpp}

In order to do operations on segments without having to worry about the lazy propagation, we can use the following functions:

\lstinputlisting{../Data Structures/Operations.cpp}

This second implementation only works for operations that have commutative and associative properties. Emphasis on the commutativity of the operation.

\section{Queue With Minimum}

The Queue With Minimum data structure is a queue that supports the following operations:

\begin{itemize}
\item \textbf{push}: Add an element to the back of the queue.
\item \textbf{pop}: Remove an element from the front of the queue.
\item \textbf{min}: Return the minimum element in the queue.
\end{itemize}

The implementation is as follows:

\lstinputlisting{../Data Structures/QueueMin.cpp}


\section{Sparse Table}

The Sparse Table is a data structure that allows answering range queries over an array effectively, while still being flexible enough to allow modifying the array. It is, in principle, a static structure. It can answer most queries in O(1), but its true power is answering range updates. For that, it takes O($\log$ n) time per update.

The implementation is as follows:

\lstinputlisting{../Data Structures/SparseTable.cpp}

\lstinputlisting{../Data Structures/SparseTableGen.cpp}


\section{Persistent Segment Tree}

The Persistent Segment Tree is a data structure that allows answering range queries over an array effectively, while still being flexible enough to allow modifying the array. It is, in principle, a static structure. It can answer most queries in O($\log$ n), but its true power is answering range updates. For that, it takes O($\log$ n) time per update.

The implementation is as follows:

\lstinputlisting{../Data Structures/PersistentSegmentTree.cpp}
