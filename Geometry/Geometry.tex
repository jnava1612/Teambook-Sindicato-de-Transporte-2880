This chapter is a survey of the main results and algorithms useful to solve geometry problems.

\section{Points and Lines}

Some of the most useful functions used while describing points and lines are:

\begin{itemize}
    \item \texttt{atan2(y,x)}: returns the angle between the positive x-axis and the vector (x,y).
    \item \texttt{hypot(x,y)}: returns the Euclidean distance between the origin and the point (x,y).
    \item \texttt{cross(a,b)}: returns the cross product of the vectors a and b.
    \item \texttt{dot(a,b)}: returns the dot product of the vectors a and b.
    \item \texttt{dist(a,b)}: returns the Euclidean distance between the points a and b.
    \item \texttt{dist2(a,b)}: returns the squared Euclidean distance between the points a and b.
    \item \texttt{ccw(a,b,c)}: returns true if the points a, b and c are in counterclockwise order.
    \item \texttt{collinear(a,b,c)}: returns true if the points a, b and c are collinear.
    \item \texttt{angle(a,b)}: returns the angle between the vectors a and b.
    \item \texttt{angle(a,b,c)}: returns the angle between the vectors a-b and c-b.
    \item \texttt{rotate(a,ang)}: returns the vector a rotated by ang radians.
    \item \texttt{rotate(a,ang,center)}: returns the vector a rotated by ang radians around the point center.
    \item \texttt{reflect(a,m)}: returns the reflection of the point a across the line m.
    \item \texttt{project(a,m)}: returns the projection of the point a onto the line m.
    \item \texttt{closest(a,m)}: returns the closest point on the line m to the point a.
    \item \texttt{intersect(a,b,c,d)}: returns true if the lines a-b and c-d intersect.
\end{itemize}

\lstinputlisting{../Geometry/PointsAndLines.cpp}


\subsection{Lines}

In order to represent lines and find their intersection, we can use the following struct:

\lstinputlisting{../Geometry/Line.cpp}


\section{Convex Hull}

The convex hull of a set of points is the smallest convex polygon that contains all the points. There are several algorithms to find the convex hull of a set of points. The most common ones are:

\begin{itemize}
    \item \textbf{Graham Scan}: This algorithm finds the convex hull in O(n log n) time. It is based on the following idea: the convex hull of a set of points is the set of points that are on the boundary of the convex hull. Therefore, we can find the convex hull by finding the points that are on the boundary of the convex hull. The algorithm works as follows:
    \lstinputlisting{../Geometry/ConvexHullGraham.cpp}
    \item \textbf{Jarvis March}: This algorithm finds the convex hull in O(nh) time, where h is the number of points on the convex hull. It is based on the following idea: we can find the convex hull by starting at a point and rotating clockwise until we reach the starting point. The algorithm works as follows:
    %\lstinputlisting{../Geometry/ConvexHullJarvis.cpp}
    \item \textbf{Monotone Chain}: This algorithm finds the convex hull in O(n log n) time. It is based on the following idea: we can find the convex hull by finding the upper and lower hulls of the set of points. The algorithm works as follows:
    \lstinputlisting{../Geometry/ConvexHullMonotone.cpp}
\end{itemize}


\section{Polygon}

A polygon is a closed plane figure that is bounded by a finite chain of straight line segments closing in a loop to form a closed chain or circuit. A polygon is simple if it does not intersect itself. A polygon is convex if it contains no line segment that is strictly inside the polygon. A polygon is monotone if it can be decomposed into a sequence of monotone polygons. A polygon is simple and convex if it is both simple and convex. A polygon is simple and monotone if it is both simple and monotone. A polygon is convex and monotone if it is both convex and monotone. A polygon is simple, convex and monotone if it is both simple, convex and monotone.

\lstinputlisting{../Geometry/Polygon.cpp}

\subsection{Triangles and Circles}

\lstinputlisting{../Geometry/Triangle.cpp}


\section{Polar Sort}

The polar sort is a sorting algorithm that sorts a set of points by their angle with respect to a given point. The algorithm works as follows:

\lstinputlisting{../Geometry/PolarSort.cpp}

