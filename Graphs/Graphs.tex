This chapter shows some of the basec algorithms and implementations required to solve problems that include graphs.

\section{Depth First Search (DFS)}

The DFS algorithm is a recursive algorithm that visits all the nodes of a graph. It is used to find connected components, topological sorting, and to find bridges and articulation points. The algorithm is as follows:

\begin{algorithm}
\caption{Depth First Search (DFS)}
\label{alg:dfs}
\begin{algorithmic}[1]
\Procedure{DFS}{$G$}
\State $visited \gets \emptyset$
\State $time \gets 0$
\State $parent \gets \emptyset$
\State $low \gets \emptyset$
\State $disc \gets \emptyset$
\State $AP \gets \emptyset$
\State $bridge \gets \emptyset$
\ForAll{$v \in V$}
\State $visited[v] \gets false$
\State $parent[v] \gets -1$
\State $low[v] \gets \infty$
\State $disc[v] \gets \infty$
\EndFor
\ForAll{$v \in V$}
\If{$visited[v] = false$}
\State DFSUtil($G$, $v$, $visited$, $time$, $parent$, $low$, $disc$, $AP$, $bridge$)
\EndIf
\EndFor
\EndProcedure
\Procedure{DFSUtil}{$G$, $v$, $visited$, $time$, $parent$, $low$, $disc$, $AP$, $bridge$}
\State $visited[v] \gets true$
\State $disc[v] \gets time$
\State $low[v] \gets time$
\State $time \gets time + 1$
\State $children \gets 0$
\ForAll{$u \in Adj(v)$}
\If{$visited[u] = false$}
\State $parent[u] \gets v$
\State $children \gets children + 1$
\State DFSUtil($G$, $u$, $visited$, $time$, $parent$, $low$, $disc$, $AP$, $bridge$)
\State $low[v] \gets min(low[v], low[u])$
\If{$parent[v] = -1$ and $children > 1$}
\State $AP[v] \gets true$
\EndIf
\If{$parent[v] != -1$ and $low[u] \geq disc[v]$}
\State $AP[v] \gets true$
\EndIf
\If{$low[u] > disc[v]$}
\State $bridge[v][u] \gets true$
\EndIf
\Else
\State $low[v] \gets min(low[v], disc[u])$
\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

The implementation can be done as follows:

%\lstinputlisting[language = C]{../dfs.cpp}

\section{Breadth First Search (BFS)}

The BFS algorithm is a non-recursive algorithm that visits all the nodes of a graph. It is used to find connected components, topological sorting, and to find bridges and articulation points, to better understand it, a propagating fire can be imagined. The algorithm is as follows:

\begin{algorithm}
\caption{Breadth First Search (BFS)}
\label{alg:bfs}
\begin{algorithmic}[1]
\Procedure{BFS}{$G$}
\State $visited \gets \emptyset$
\State $time \gets 0$
\State $parent \gets \emptyset$
\State $low \gets \emptyset$
\State $disc \gets \emptyset$
\State $AP \gets \emptyset$
\State $bridge \gets \emptyset$
\ForAll{$v \in V$}
\State $visited[v] \gets false$
\State $parent[v] \gets -1$
\State $low[v] \gets \infty$
\State $disc[v] \gets \infty$
\EndFor
\ForAll{$v \in V$}
\If{$visited[v] = false$}
\State BFSUtil($G$, $v$, $visited$, $time$, $parent$, $low$, $disc$, $AP$, $bridge$)
\EndIf
\EndFor
\EndProcedure
\Procedure{BFSUtil}{$G$, $v$, $visited$, $time$, $parent$, $low$, $disc$, $AP$, $bridge$}
\State $visited[v] \gets true$
\State $disc[v] \gets time$
\State $low[v] \gets time$
\State $time \gets time + 1$
\State $children \gets 0$
\ForAll{$u \in Adj(v)$}
\If{$visited[u] = false$}
\State $parent[u] \gets v$
\State $children \gets children + 1$
\State BFSUtil($G$, $u$, $visited$, $time$, $parent$, $low$, $disc$, $AP$, $bridge$)
\State $low[v] \gets min(low[v], low[u])$
\If{$parent[v] = -1$ and $children > 1$}
\State $AP[v] \gets true$
\EndIf
\If{$parent[v] != -1$ and $low[u] \geq disc[v]$}
\State $AP[v] \gets true$
\EndIf
\If{$low[u] > disc[v]$}
\State $bridge[v][u] \gets true$
\EndIf
\Else
\State $low[v] \gets min(low[v], disc[u])$
\EndIf
\EndFor
\EndProcedure
\end{algorithmic}
\end{algorithm}

The implementation can be done as follows:

%\inputminted{c++}{Graphs/BFS.cpp}
\lstinputlisting{../Graphs/BFS.cpp}

%\VerbatimInput{Graphs/BFS.cpp}
