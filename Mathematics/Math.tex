This chapter is about some useful mathematical tools needed in order to solve problems.

\section{GCD and LCM}

In order to find the greatest common divisor (GCD) of two numbers, the Euclidean algorithm can be used. The implementation is as follows:

\lstinputlisting{../Mathematics/Euclid.cpp}

Another (and faster) way to find the GCD is by using the following code:

\lstinputlisting{../Mathematics/FastGCD.cpp}

The way Halim suggests to find the GCD and the LCM is given by the following code:

\lstinputlisting{../Mathematics/HalimGCD.cpp}

\section{Prime Numbers}

The fastest way to check the primality of a number is by using Erathostenes' sieve. The typical implementation is as follows:

\lstinputlisting{../Mathematics/Erathostenes.cpp}

Nevertheless, the following implementation is faster, since  the statement if 
\begin{verbatim}
if (i % prime[j] == 0) break;
\end{verbatim}
 terminates the loop when p divides i. The inner loop is executed only once for each composite. Hence, the code performs in O(n) complexity, resulting in the 'linear' sieve:

\lstinputlisting{../Mathematics/LinearSieve.cpp}


%\VerbatimInput{Graphs/BFS.cpp}


\section{Modular Arithmetic}

The modular inverse is defined by the following equation:

\begin{equation}
a \cdot a^{-1} \equiv 1 \mod m
\end{equation}

The following code shows how to find the modular inverse of a number:

\lstinputlisting{../Mathematics/ModularInverse.cpp}

Some other useful relationships in modular arithmetic are:

\begin{itemize}
\item $ (a+b) \mod m = (a \mod m + b \mod m) \mod m $
\item $ (a-b) \mod m = (a \mod m - b \mod m) \mod m $
\item $ (a*b) \mod m = (a \mod m * b \mod m) \mod m $
\item $ (a/b) \mod m = (a \mod m * b^{-1} \mod m) \mod m $
\item $ (a^b) \mod m = (a \mod m)^b \mod m $
\item $ (a^b) \mod m = (a \mod m)^{b \mod \phi(m)} \mod m $
\item $ (a^b) \mod m = (a \mod m)^{b \mod (m-1)} \mod m $
\item $ \frac{a}{k} \equiv \frac{a}{k} \mod m \iff a \equiv k \mod m $
\item $ \frac{a}{k} \equiv \frac{a}{k} \left( \mod \frac{n}{\gcd (n,k)}\right)$
\end{itemize}


\section{Matrix Exponentiation}

The following code shows how to find the nth power of a \textit{mat}, noting that a data structure of type matrix is defined as follows:

\lstinputlisting{../Mathematics/MatrixPower.cpp}