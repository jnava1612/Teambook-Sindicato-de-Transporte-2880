This chapter shows some useful algorithms and implementations required to solve problems that require Dynamic Programming.

Some of the algorithms and implementations are as follows:

\lstinputlisting{../DP/dp1.cpp}

\lstinputlisting{../DP/dp2.cpp}

\lstinputlisting{../DP/dp3.cpp}

\lstinputlisting{../DP/dp4.cpp}

\lstinputlisting{../DP/dp5.cpp}

\lstinputlisting{../DP/dp6.cpp}

\lstinputlisting{../DP/dp7.cpp}

\lstinputlisting{../DP/dp8.cpp}

\section{Knapsack Problem}

The knapsack problem is a problem that consists of finding the maximum value of a set of items that can be placed in a knapsack of a given weight. The problem can be solved using Dynamic Programming.

The implementation can be done as follows:

\lstinputlisting{../DP/knapsack.cpp}

\lstinputlisting{../DP/knapsack2.cpp}

\section{Divide and Conquer}

The divide and conquer algorithm is a recursive algorithm that divides the problem into smaller subproblems and solves them recursively. The algorithm is as follows:

\begin{algorithm}
\caption{Divide and Conquer}
\label{alg:divideandconquer}
\begin{algorithmic}[1]
\Procedure{DivideAndConquer}{$A$}
\If{$A$ has only one element}
\State return $A$
\EndIf
\State $B \gets DivideAndConquer($A[0..n/2]$)$
\State $C \gets DivideAndConquer($A[n/2+1..n]$)$
\State return $Merge(B, C)$
\EndProcedure
\end{algorithmic}
\end{algorithm}

The implementation can be done as follows:

\lstinputlisting{../DP/DivideAndConquer.cpp}

\lstinputlisting{../DP/DivideAndConquer2.cpp}

\section{Digit DP}


\lstinputlisting{../DP/digitdp.cpp}

\section{Alien's Trick}


\lstinputlisting{../DP/alienstrick.cpp}

\section{Bitwise Digit DP}


\lstinputlisting{../DP/bitwisedigitdp.cpp}

\section{Broken Profile}


\lstinputlisting{../DP/BrokenProfile.cpp}

\section{CHT}


\lstinputlisting{../DP/CHT.cpp}

A dynamical implementation for the CHT can be done as follows:

\lstinputlisting{../DP/CHT2.cpp}


\section{Exchange Arguments}


\lstinputlisting{../DP/ExchangeArguments.cpp}


\section{Expected Value}


\lstinputlisting{../DP/ExpectedValue.cpp}

\section{Largest Sum Contiguous Subarray}


\lstinputlisting{../DP/LargestSumContiguousSubarray.cpp}

\section{Largest Square}


\lstinputlisting{../DP/LargestSquare.cpp}

\section{Least Common Subsequence}


\lstinputlisting{../DP/LCS.cpp}

\section{Lichao}

\lstinputlisting{../DP/Lichao.cpp}

\section{Longest Increasing Subsequence}

\lstinputlisting{../DP/LIS.cpp}

\section{Maximum Matrix Path}

\lstinputlisting{../DP/MaximumMatrixPath.cpp}

\section{SOS DP}

\lstinputlisting{../DP/SOSDP.cpp}


\section{Subsequence String}

\lstinputlisting{../DP/SubsequenceString.cpp}

\section{Subset Sum}

\lstinputlisting{../DP/SubsetSum.cpp}

\section{TIP}

\lstinputlisting{../DP/TIP.cpp}

\section{Atcoder DP Contest}

\lstinputlisting{../DP/atcoder/A - Frog 1.cpp}

\lstinputlisting{../DP/atcoder/B - Frog 2.cpp}

\lstinputlisting{../DP/atcoder/C - Vacation.cpp}

\lstinputlisting{../DP/atcoder/D - Knapsack 1.cpp}

\lstinputlisting{../DP/atcoder/E - Knapsack 2.cpp}

\lstinputlisting{../DP/atcoder/F - LCS.cpp}

\lstinputlisting{../DP/atcoder/G - Longest Path.cpp}

\lstinputlisting{../DP/atcoder/H - Grid 1.cpp}

\lstinputlisting{../DP/atcoder/I - Coins.cpp}

\lstinputlisting{../DP/atcoder/J - Sushi.cpp}

\lstinputlisting{../DP/atcoder/K - Stones.cpp}

\lstinputlisting{../DP/atcoder/L - Deque.cpp}

\lstinputlisting{../DP/atcoder/M - Candies.cpp}

\lstinputlisting{../DP/atcoder/N - Slimes.cpp}

\lstinputlisting{../DP/atcoder/O - Matching.cpp}

\lstinputlisting{../DP/atcoder/P - Independent Set.cpp}

\lstinputlisting{../DP/atcoder/Q - Flowers.cpp}

\lstinputlisting{../DP/atcoder/R - Walk.cpp}

\lstinputlisting{../DP/atcoder/S - Digit Sum.cpp}

\lstinputlisting{../DP/atcoder/T - Permutation.cpp}

\lstinputlisting{../DP/atcoder/U - Grouping.cpp}

\lstinputlisting{../DP/atcoder/V - Subtree.cpp}

\lstinputlisting{../DP/atcoder/X - Tower.cpp}

\lstinputlisting{../DP/atcoder/Y - Grid 2.cpp}

